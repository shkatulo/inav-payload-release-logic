<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    body {
      font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
      color: #333333;
      padding-bottom: 50px;
    }

    a {
      color: steelblue;
      cursor: pointer;
    }

    #root-container {
      max-width: 720px;
      margin: 0 auto;
    }

    p.info {
      border-left: 5px solid green;
      padding-left: 10px;
    }

    p.warning {
      border-left: 5px solid red;
      padding-left: 10px;
    }

    #root-layout th {
      padding-top: 40px;
      text-align: start;
      text-decoration: underline;
      font-size: 12pt;
    }

    #parameters {
      width: min-content;
      margin-bottom: 10px;
    }

    #parameters .note {
      font-size: 8pt;
      color: grey;
      border-bottom: 1px solid grey;
    }

    #calculate {
      background-color: rgb(191, 253, 191);
      border-radius: 10px;
      padding: 8px;
    }

    #calculate:hover {
      background-color: rgb(144, 255, 144);
    }

    #calculate:active {
      background-color: #eeeeee;
    }

    #rows-used {
      font-size: 12pt;
    }

    #result {
      background-color: #eeeeee;
      padding: 10px;
      border-radius: 10px;
      margin-bottom: 10px;
    }
  </style>
</head>

<body>
  <div id="root-container">
    <h1>Помічник налаштування механізму подвійного скидання для INav</h1>
    <p class="info">За допомогою цього помічника ви зможете легко модифікувати команди керування скидом, щоб помістити
      його логіку у
      вільне місце на вкладці Programming і задати потрібний канал керування.</p>

    <table id="root-layout">
      <tr>
        <th>Параметри</th>
      </tr>
      <tr>
        <td>
          <table id="parameters">
            <tr>
              <td>Номер&nbsp;рядка:</td>
              <td>
                <input id="row-number" name="field-name" type="number" value="0" />
              </td>
            </tr>
            <tr>
              <td colspan="2" class="note">
                Номер рядка на вкладці Programming, в якому буде розміщено першу команду програми керування скидом.
              </td>
            </tr>
            <tr>
              <td>Номер&nbsp;рканалу:</td>
              <td>
                <input id="rc-channel" name="field-name" type="number" value="11" />
              </td>
            </tr>
            <tr>
              <td colspan="2" class="note">
                Номер RC-каналу, який буде використовуватись для керування скидом.
              </td>
            </tr>
          </table>

          <input id="calculate" value="Застосувати" type="button" onclick="javascript:calculate()" />
        </td>
      </tr>
      <tr>
        <th>Зайняті рядки</th>
      </tr>
      <tr>
        <td>
          <span id="rows-used">?</span>
          <p class="warning"><b>ЗВЕРНІТЬ УВАГУ!</b> Щоб не зламати роботу інших функцій, що вже налаштовані на вкладці
            Programming, цей
            діапазон рядків має бути порожнім! Якщо він зайнятий, в параметрі "номер рядка" вкажіть рядок, за яким іде
            достатня кількість вільного місця.</p>
        </td>
      </tr>
      <tr>
        <th>Команди</th>
      </tr>
      <tr>
        <td>
          <div id="result">(Натисніть "Застосувати", щоб отримати команди INav CLI)</div>
          <a onclick="javascript:copyResult()">(скопіювати)</a>
        </td>
      </tr>
    </table>
  </div>



  <!-- **************************** -->
  <!-- ********** SCRIPT ********** -->
  <!-- **************************** -->
  <script type="text/javascript">
    const ORIGINAL_LOGIC = `
logic 57 1 -1 1 3 0 0 0 0
logic 58 1 -1 48 4 57 0 5000 0
logic 59 1 58 5 1 {rc-channel} 0 0 0
logic 60 1 59 18 0 6 0 1 0
logic 61 1 -1 1 5 6 0 1 0
logic 62 1 61 15 1 {rc-channel} 0 1500 0
logic 63 1 61 18 0 5 4 62 0
    `;

    const OPERAND_CONST = 0
    const OPERAND_LC = 4

    function parseLogicRow(row) {
      const parts = row.trim().split(" ")
      if (parts.length !== 10 || parts[0] !== "logic") return
      return {
        index: +parts[1],
        row: {
          enabled: +parts[2],
          activatorId: +parts[3],
          operation: +parts[4],
          operandAType: +parts[5],
          operandAValue: +parts[6],
          operandBType: +parts[7],
          operandBValue: +parts[8],
          flags: +parts[9]
        }
      }
    }

    function formatLogicRow(row, index) {
      return (
        `logic ${index} ${row.enabled} ${row.activatorId} ${row.operation} ` +
        `${row.operandAType} ${row.operandAValue} ${row.operandBType} ${row.operandBValue} ${row.flags}`
      )
    }

    function parseLogicDump(dump) {
      const rows = [];

      const parts = dump.split("\n")
      parts.map(part => {
        const { row, index } = parseLogicRow(part) ?? {}
        if (row && index !== undefined) rows[index] = row
      })

      const keys = Object.keys(rows);
      const length = +keys[keys.length - 1] + 1;

      for (let i = 0; i < length; i++) {
        rows[i] = rows[i] ?? null // Replace missing elements by nulls
      }

      return rows
    }

    function formatLogicDump(rows, withDisabled = false) {
      const parts = rows
        .map((row, index) =>
          row && (withDisabled || row.enabled) ? formatLogicRow(row, index) : null
        )
        .filter(r => r)
      return [
        "batch start",
        "logic reset",
        ...parts,
        "batch end",
      ].join("\n")
    }

    // ***** Operations *****
    function updateRow(row, offset, fromIndex, toIndex) {
      // Shift activator
      if (
        !row.activatorRefUpdated &&
        row.activatorId > -1 &&
        row.activatorId >= fromIndex &&
        (toIndex === undefined || row.activatorId <= toIndex)
      ) {
        if (offset) row.activatorId += offset
        else {
          console.warn("Deleted activator condition", row)
          row.activatorId = -1
        }
        row.activatorRefUpdated = true
      }

      // Shift operand A
      if (
        !row.operandARefUpdated &&
        row.operandAType === OPERAND_LC &&
        row.operandAValue >= fromIndex &&
        (toIndex === undefined || row.operandAValue <= toIndex)
      ) {
        if (offset) row.operandAValue += offset
        else {
          console.warn("Deleted operand A reference", row)
          row.operandAType = OPERAND_CONST
          row.operandAValue = -111111
        }
        row.operandARefUpdated = true
      }

      // Shift operand B
      if (
        !row.operandBRefUpdated &&
        row.operandBType === OPERAND_LC &&
        row.operandBValue >= fromIndex &&
        (toIndex === undefined || row.operandBValue <= toIndex)
      ) {
        if (offset) row.operandBValue += offset
        else {
          console.warn("Deleted operand B reference", row)
          row.operandBType = OPERAND_CONST
          row.operandBValue = -111111
        }
        row.operandBRefUpdated = true
      }
    }

    function resetUpdatedState(rows) {
      rows.forEach(row => {
        if (row) {
          row.activatorRefUpdated = false
          row.operandARefUpdated = false
          row.operandBRefUpdated = false
        }
      })
    }

    function insert(rows, index, count) {
      resetUpdatedState(rows)

      // Offset refs
      rows.forEach(row => {
        if (row) updateRow(row, count, index)
      })

      // Insert
      rows.splice(index, 0, ...new Array(count).fill(null))

      return rows
    }

    function remove(rows, index, count) {
      resetUpdatedState(rows)

      // Remove refs
      const to = index + count - 1
      rows.forEach(row => {
        if (row) updateRow(row, 0, index, to)
      })

      // Offset refs
      const fr = index + count
      rows.forEach(row => {
        if (row) updateRow(row, -count, fr)
      })

      // Remove
      rows.splice(index, count)

      return rows
    }

    function move(rows, indexFrom, count, indexTo) {
      resetUpdatedState(rows)

      const offset = indexTo - indexFrom

      // Offset refs to moved block
      const to = indexFrom + count - 1
      rows.forEach(row => {
        if (row) updateRow(row, offset, indexFrom, to)
      })

      // Offset refs to pushed items
      if (offset > 0) {
        const fr = indexFrom + count
        const to = fr + offset - 1
        rows.forEach(row => {
          if (row) updateRow(row, -count, fr, to)
        })
      } else {
        const fr = indexFrom + offset
        const to = indexFrom - 1
        rows.forEach(row => {
          if (row) updateRow(row, count, fr, to)
        })
      }

      // Cut items
      const cut = rows.splice(indexFrom, count)

      // Extend array, if needed
      if (rows.length < indexTo) {
        const empty = new Array(indexTo - rows.length).fill(null)
        console.log(empty)
        rows.push(...empty)
      }

      // Insert at new place
      rows.splice(indexTo, 0, ...cut)

      return rows
    }

    function validateValue(value, rule) {
      if (rule.isNumber) {
        if (isNaN(value)) {
          throw `Параметр "${rule.name}" не є числом`;
        }

        const numValue = rule.round ? Math.round(+value) : +value;
        if (rule.min !== undefined && numValue < rule.min) {
          throw `Параметр "${rule.name}" не може бути меншим за ${rule.min}`;
        }
        if (rule.max !== undefined && numValue > rule.max) {
          throw `Параметр "${rule.name}" не може бути більшим за ${rule.max}`;
        }
        return numValue;
      }
      return value;
    }

    function clearResults() {
      document.getElementById('rows-used').innerText = '';
      document.getElementById('result').innerText = '(Натисніть "Застосувати", щоб отримати команди INav CLI)';
    }

    function calculate() {
      clearResults();

      // Pre-validate values
      const rules = {
        'rc-channel': { name: 'номер каналу', isNumber: true, round: true, min: 5, max: 16 },
        'row-number': { name: 'номер рядка', isNumber: true, round: true },
      };

      const values = {};
      let validationError = '';
      Object.keys(rules).forEach(key => {
        const value = document.getElementById(key).value;
        const rule = rules[key];

        try {
          const validated = validateValue(value, rule);
          values[key] = validated;
        }
        catch (error) {
          validationError = error;
        }
      });

      if (validationError) {
        alert(validationError);
        return;
      }

      // Replace placeholders
      const replacements = ['rc-channel'];
      let logic = ORIGINAL_LOGIC;
      replacements.forEach(key => {
        const value = values[key];
        logic = logic.replaceAll(`{${key}}`, value);
      });

      // Parse
      const parsed = parseLogicDump(logic);
      const rowNumber = values['row-number'];
      const startRowNum = parsed.findIndex(r => r);
      const endRowNum = parsed.length - [...parsed].reverse().findIndex(r => r) - 1;
      const rowsCount = endRowNum - startRowNum + 1;

      // Validate row number
      try {
        const rule = { name: 'номер рядка', isNumber: true, round: true, min: 0, max: 64 - rowsCount };
        validateValue(values['row-number'], rule);
      }
      catch (error) {
        alert(error);
        return;
      }

      // Move
      move(parsed, startRowNum, rowsCount, rowNumber);
      const formatted = formatLogicDump(parsed);

      document.getElementById('rows-used').innerText = `${rowNumber} - ${rowNumber + endRowNum - startRowNum}`;
      document.getElementById('result').innerText = formatted;
    }

    function copyResult() {
      const result = document.getElementById('result').innerText;
      navigator.clipboard.writeText(result);
      alert('Скопійовано в буфер обміну!');
    }

    window.calculate = calculate;
    window.copyResult = copyResult;
  </script>
</body>

</html>