<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
  <h1>Параметри</h1>
  <label>
    Номер рядка:
    <input id="row-number" name="field-name" type="number" min="0" max="57" value="0" />
  </label>
  <br />
  <label>
    Номер каналу:
    <input id="rc-channel" name="field-name" type="number" min="5" max="16" value="11" />
  </label>
  <br /><br />
  <input value="Submit" type="button" onclick="javascript:calculate()" />

  <h1>Зайняті рядки</h1>
  <span id="rows-from"></span> - <span id="rows-to"></span>

  <h1>Команди</h1>
  <div id="result"></div>

  <script type="text/javascript">
    const ORIGINAL_LOGIC = `
logic 57 1 -1 1 3 0 0 0 0
logic 58 1 -1 48 4 57 0 5000 0
logic 59 1 58 5 1 {rc-channel} 0 0 0
logic 60 1 59 18 0 6 0 1 0
logic 61 1 -1 1 5 6 0 1 0
logic 62 1 61 15 1 {rc-channel} 0 1500 0
logic 63 1 61 18 0 5 4 62 0
    `;

    const OPERAND_CONST = 0
    const OPERAND_LC = 4

    function parseLogicRow(row) {
      const parts = row.trim().split(" ")
      if (parts.length !== 10 || parts[0] !== "logic") return
      return {
        index: +parts[1],
        row: {
          enabled: +parts[2],
          activatorId: +parts[3],
          operation: +parts[4],
          operandAType: +parts[5],
          operandAValue: +parts[6],
          operandBType: +parts[7],
          operandBValue: +parts[8],
          flags: +parts[9]
        }
      }
    }

    function formatLogicRow(row, index) {
      return (
        `logic ${index} ${row.enabled} ${row.activatorId} ${row.operation} ` +
        `${row.operandAType} ${row.operandAValue} ${row.operandBType} ${row.operandBValue} ${row.flags}`
      )
    }

    function parseLogicDump(dump) {
      const rows = [];

      const parts = dump.split("\n")
      parts.map(part => {
        const { row, index } = parseLogicRow(part) ?? {}
        if (row && index !== undefined) rows[index] = row
      })

      const keys = Object.keys(rows);
      const length = +keys[keys.length - 1] + 1;

      for (let i = 0; i < length; i++) {
        rows[i] = rows[i] ?? null // Replace missing elements by nulls
      }

      return rows
    }

    function formatLogicDump(rows, withDisabled = false) {
      const parts = rows
        .map((row, index) =>
          row && (withDisabled || row.enabled) ? formatLogicRow(row, index) : null
        )
        .filter(r => r)
      return [
        "batch start",
        "logic reset",
        ...parts,
        "batch end",
      ].join("\n")
    }

    // ***** Operations *****
    function updateRow(row, offset, fromIndex, toIndex) {
      // Shift activator
      if (
        !row.activatorRefUpdated &&
        row.activatorId > -1 &&
        row.activatorId >= fromIndex &&
        (toIndex === undefined || row.activatorId <= toIndex)
      ) {
        if (offset) row.activatorId += offset
        else {
          console.warn("Deleted activator condition", row)
          row.activatorId = -1
        }
        row.activatorRefUpdated = true
      }

      // Shift operand A
      if (
        !row.operandARefUpdated &&
        row.operandAType === OPERAND_LC &&
        row.operandAValue >= fromIndex &&
        (toIndex === undefined || row.operandAValue <= toIndex)
      ) {
        if (offset) row.operandAValue += offset
        else {
          console.warn("Deleted operand A reference", row)
          row.operandAType = OPERAND_CONST
          row.operandAValue = -111111
        }
        row.operandARefUpdated = true
      }

      // Shift operand B
      if (
        !row.operandBRefUpdated &&
        row.operandBType === OPERAND_LC &&
        row.operandBValue >= fromIndex &&
        (toIndex === undefined || row.operandBValue <= toIndex)
      ) {
        if (offset) row.operandBValue += offset
        else {
          console.warn("Deleted operand B reference", row)
          row.operandBType = OPERAND_CONST
          row.operandBValue = -111111
        }
        row.operandBRefUpdated = true
      }
    }

    function resetUpdatedState(rows) {
      rows.forEach(row => {
        if (row) {
          row.activatorRefUpdated = false
          row.operandARefUpdated = false
          row.operandBRefUpdated = false
        }
      })
    }

    function insert(rows, index, count) {
      resetUpdatedState(rows)

      // Offset refs
      rows.forEach(row => {
        if (row) updateRow(row, count, index)
      })

      // Insert
      rows.splice(index, 0, ...new Array(count).fill(null))

      return rows
    }

    function remove(rows, index, count) {
      resetUpdatedState(rows)

      // Remove refs
      const to = index + count - 1
      rows.forEach(row => {
        if (row) updateRow(row, 0, index, to)
      })

      // Offset refs
      const fr = index + count
      rows.forEach(row => {
        if (row) updateRow(row, -count, fr)
      })

      // Remove
      rows.splice(index, count)

      return rows
    }

    function move(rows, indexFrom, count, indexTo) {
      resetUpdatedState(rows)

      const offset = indexTo - indexFrom

      // Offset refs to moved block
      const to = indexFrom + count - 1
      rows.forEach(row => {
        if (row) updateRow(row, offset, indexFrom, to)
      })

      // Offset refs to pushed items
      if (offset > 0) {
        const fr = indexFrom + count
        const to = fr + offset - 1
        rows.forEach(row => {
          if (row) updateRow(row, -count, fr, to)
        })
      } else {
        const fr = indexFrom + offset
        const to = indexFrom - 1
        rows.forEach(row => {
          if (row) updateRow(row, count, fr, to)
        })
      }

      // Cut items
      const cut = rows.splice(indexFrom, count)

      // Extend array, if needed
      if (rows.length < indexTo) {
        const empty = new Array(indexTo - rows.length).fill(null)
        console.log(empty)
        rows.push(...empty)
      }

      // Insert at new place
      rows.splice(indexTo, 0, ...cut)

      return rows
    }

    function calculate() {
      // TODO: Validate values

      // Replace placeholders
      const replacements = ['rc-channel'];
      let logic = ORIGINAL_LOGIC;
      replacements.forEach(key => {
        const value = document.getElementById(key).value;
        logic = logic.replaceAll(`{${key}}`, value);
      });

      // Parse and move
      const parsed = parseLogicDump(logic);
      const rowNumber = +document.getElementById('row-number').value;
      const startRowNum = parsed.findIndex(r => r);
      const endRowNum = parsed.length - [...parsed].reverse().findIndex(r => r) - 1;

      move(parsed, startRowNum, endRowNum - startRowNum + 1, rowNumber);
      const formatted = formatLogicDump(parsed);

      document.getElementById('rows-from').innerText = rowNumber;
      document.getElementById('rows-to').innerText = rowNumber + endRowNum - startRowNum;
      document.getElementById('result').innerText = formatted;
    }

    window.calculate = calculate;
  </script>
</body>

</html>